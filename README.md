# Tutorial on Handling Event Driven Data Stream -- Optical Flow
This tutorial introduces additional functionalities of the event-driven library. We will use an example application, the **event-driven optical flow**.

# Requirements:
By now you should know the basics of event-driven library (from [tutorial_event-driven-handling](https://github.com/vvv-school/tutorial_event-handling)).

# The event-driven library

In this tutorial you need to include it in your header file `vOptFlow.h`. 

```javascript
#include "iCub/eventdriven/all.h"
using namespace ev;
``` 

In this tutorial you will learn:

- Datastructures

  - vtsHelper

### Events in event-driven libraries:
Different types of events can be defined, inheriting from the basic type **vEvent** that holds the _timestamp_ of the event. We can then create other types of events:

![IMAGE OF INHERITANCE](./misc/vEventInherit.png)

```javascript
EXAMPLE OF VEVENT - snapshot of code - store time
//FILL HERE THE CODE

``` 

A new event type can add information to the current event, or a completely new event can be generated by a module:

- ADDRESSEVENT (AE)  - you should know by now....
- FLOWEVENT     - adds dx/dt and dy/dt
- CLUSTER EVENT - if a cluster is detected creates a new event with x,y of the cluster centre of mass, vx, vy, m (number of events forming the cluster)

(shared memory) event pointers are declared as `event<AddressEvent>` or (as events are all inhereted from vEvent) we can point to any type with `event<> //is equal to event<vEvent>`.

to move down the inheretence we can use:

```javascript
event<> v_any = ...
event<FlowEvent> v = getas<FlowEvent>(v_any);
```

if v_any is not a flowEvent v = 0;
if v_any is a flowEvent we can access x, y, dx/dt and dy/dt;

This tutorial will have this structure:

![optflow](./misc/tutorial2.png)


### vtsHelper

Timestamps are stored with (at the moment) 24 bits (unsigned integer) and the clock performing timestamps has a period of 80 nanoseconds.
If we do the maths we will overflow every: 2^24 * 80e-9 = 1.34217728 seconds. Therefore our code needs to handle overflows ("timestamp wraps").

```javascript
//ADD CODE SNIPPET FOR VTSHELPER
```

Instantiating a `vtsHelper` can be used to convert timestamps to a  long unsigned int (many years before an overflow):

```javascript
vtsHelper unwrap;
event<> v;
unsigned long int unwrappedstamp = unwrap(v->getStamp());
```

##### NOTE: We don't send the unwrapped timestamps in bottles so every module needs to track its own unwrapped timestamp

Alternatively, as we often only need relative time between events, we can account for wraps using:

```javascript
event<> v; //allocated somewhere

int currenttimestamp = v->getStamp();
int previoustimestamp;
if(previoustimstamp > currenttimestamp) //assuming events are in chronological order this indicates a wrap
    previoustimestamp -= vtsHelper::getMaxStamp();
int dt = currenttimestamp - previoustimestamp;
```


























